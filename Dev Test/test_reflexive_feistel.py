import torch
import time
import numpy as np

"""
REFLEXIVE FEISTEL DIFFUSION: MATHEMATICAL FORMALIZATION

1. FEISTEL OPERATOR (F):
   L_{i+1} = R_i
   R_{i+1} = L_i ^ f(R_i, K_i)
   where f is the round function and K is the seed-key.

2. THE REFLEXIVE CONJECTURE:
   Let W_k be the weight manifold generated by a k-round Feistel network.
   W_4 = W_2 + Delta_{2 -> 4}  (using raw string to avoid escapes)
   
   The residual represents the higher-order structural complexity.
   Persistence Check: If CosineSim(HV(W_2), HV(W_4)) >> 0, then W_2 is a 
   structurally valid holographic proxy for the full manifold.

3. HOMOMORPHIC DIFFUSION:
   Y = X * (W_2 + \epsilon \cdot \Delta)
   where \epsilon is a precision scaling factor determined by the Stability Gate.
"""

def feistel_round(l, r, key, mul=0x94D049BB):
    """Single Feistel round mapping."""
    f = (torch.bitwise_xor(r, key) * mul) & 0xFFFFFFFF
    f = (torch.bitwise_xor(f >> 16, f)) & 0xFFFFFFFF
    return r, torch.bitwise_xor(l, f)

def v_mask_k_rounds(addr, k=4, seed=0xBF58476D):
    """Parameterized k-round Feistel hash."""
    l = (addr >> 32) & 0xFFFFFFFF
    r = addr & 0xFFFFFFFF
    
    device = addr.device
    k_t = torch.tensor(seed, device=device)
    
    for _ in range(k):
        l, r = feistel_round(l, r, k_t)
        
    res = (l << 32) | r
    return (res.float() / float(2**64)) * 2.0 - 1.0

def test_reflexive_feistel():
    print(">>> Testing Reflexive Feistel Diffusion (HDC Persistence)")
    
    # 512 x 512 weight matrix (faster for HDC projection)
    dim = 512
    rows = torch.arange(dim).unsqueeze(1)
    cols = torch.arange(dim).unsqueeze(0)
    coords = (42 ^ rows ^ cols).long()
    
    # Measure 2-round "Dream"
    w_dream = v_mask_k_rounds(coords, k=2)
    
    # Measure 4-round "Ground Truth"
    w_truth = v_mask_k_rounds(coords, k=4)
    
    # Calculate HDC Similarity (Flattening to Hypervectors)
    hv_dream = w_dream.view(-1)
    hv_truth = w_truth.view(-1)
    
    # Cosine Similarity: (A . B) / (|A||B|)
    sim = torch.nn.functional.cosine_similarity(hv_dream.unsqueeze(0), hv_truth.unsqueeze(0)).item()
    
    print(f"HDC Bitwise Similarity (2 vs 4 Rounds): {sim:.6f}")
    
    # Diffusion Filter Concept:
    # If sim > 0, we can use the 2-round dream as a 'noisy' base and 
    # the transformer's hidden state as a diffusion refiner.
    if sim > 0.01:
        print(f"SUCCESS: Structural Persistence detected ({sim:.6f}). Reflexive Dreaming is viable.")
    else:
        print(f"FAIL: Total decorrelation ({sim:.6f}). Feistel rounds are too chaotic for O(1) dreaming.")

    # Speed Benchmark with larger N to see caching effect
    print("\n>>> Speed Benchmark (N=2048)")
    coords_large = torch.arange(2048*2048).long()
    t0 = time.perf_counter()
    v_mask_k_rounds(coords_large, k=2)
    d2 = (time.perf_counter() - t0) * 1000
    t0 = time.perf_counter()
    v_mask_k_rounds(coords_large, k=4)
    d4 = (time.perf_counter() - t0) * 1000
    print(f"2-Round: {d2:.2f}ms | 4-Round: {d4:.2f}ms | Optimization: {((d4-d2)/d4)*100:.1f}%")

if __name__ == "__main__":
    test_reflexive_feistel()
